#!/bin/bash
 
__lftp="/usr/bin/lftp"



for __ in "$(dirname $0)/lib-"* ; do . "${__}" ; done



check_binary()
{
    [ -x "${__lftp}" ] || return ${EXITCODE_ERROR}

    return ${EXITCODE_NO_ERROR}
}


show_usage()
{
    cat <<TXT
Usage: $0 -s source_description -d destination_description
    Local Description: \${LOCAL_PATH}
    Remote Description: [\${REMOTE_USER}[:\${REMOTE_PASSWORD}]@]\${REMOTE_HOST}[:\${REMOTE_PORT}]:[\${REMOTE_PATH}]
TXT
    exit ${EXITCODE_WARNING}
}


generate_setting_command()
{
    cat <<CMD
set ftp:passive-mode off
set ftp:ssl-force on
set ftp:ssl-allow on
set ftp:ssl-protect-data on
set ssl:verify-certificate off
CMD

    return ${EXITCODE_NO_ERROR}
}


generate_connect_command()
{
    local _user="${1}"
    local _pass="${2}"
    local _host="${3}"
    local _port="${4}"

    [ -z "${_user}" ] && return ${EXITCODE_ERROR}
    [ -z "${_pass}" ] && return ${EXITCODE_ERROR}
    [ -z "${_host}" ] && return ${EXITCODE_ERROR}
    [ -z "${_port}" ] && return ${EXITCODE_ERROR}

    cat <<CMD
open -u ${_user},${_pass} -p ${_port} ${_host}
CMD

    return ${EXITCODE_NO_ERROR}
}


generate_disconnect_command()
{
    cat <<CMD
close
CMD

    return ${EXITCODE_NO_ERROR}
}


generate_end_command()
{
    cat <<CMD
quit
CMD

    return ${EXITCODE_NO_ERROR}
}


_generate_simple_command()
{
    local _command="${1}"

    [ -z "${_command}" ] && return ${EXITCODE_ERROR}

    cat <<CMD
${1}
CMD

    return ${EXITCODE_NO_ERROR}
}


generate_list_remote_command()
{
    _generate_simple_command "ls"

    return $?
}


_generate_mirror_command()
{
    local _s="${1}"; shift

    [ -z "${_s}" ] && return ${EXITCODE_ERROR}
    [ -z "${_d}" ] && return ${EXITCODE_ERROR}

    cat <<CMD
mirror -a -e ${_o} --verbose=0 ${_s} ${_d}
CMD
}


generate_mirror_local_command()
{
    #local _s_remote="${1}"
    #local _d_local="${2}"

    _generate_mirror_command "${1}" "${2}" ""

    return ${?}
}


generate_mirror_remote_command()
{
    #local _s_local="${1}"
    #local _d_remote="${2}"

    _generate_mirror_command "${1}" "${2}" "-R"

    return ${?}
}


#show_usage

_desc_src=
_desc_dst=
while getopts s:d: OPT
do
    case "${OPT}" in
    s)
        _desc_src="${OPTARG}"
        ;;
    d)
        _desc_dst="${OPTARG}"
        ;;
    esac
done

#echo "SRC_DESC = ${_desc_src}"
#echo "DST_DESC = ${_desc_dst}"


_username=
_password=
_hostname=
_portnum=
_path_src=
_path_dst=
_remote_to_local=

if [[ "${_desc_src}" =~ ^(([^@:]*)(:([^@]*))?@)?([^:]*):?([^:]*)?:(.*) ]]
then
    _username="${BASH_REMATCH[2]}"
    _password="${BASH_REMATCH[4]}"
    _hostname="${BASH_REMATCH[5]}"
    _portnum="${BASH_REMATCH[6]}"
    _path_src="${BASH_REMATCH[7]}"
    _remote_to_local="TRUE"
    _path_dst="${_desc_dst}"
elif [[ "${_desc_dst}" =~ ^(([^@:]*)(:([^@]*))?@)?([^:]*):?([^:]*)?:(.*) ]]
then
    _username="${BASH_REMATCH[2]}"
    _password="${BASH_REMATCH[4]}"
    _hostname="${BASH_REMATCH[5]}"
    _portnum="${BASH_REMATCH[6]}"
    _path_dst="${BASH_REMATCH[7]}"
    _remote_to_local="FALSE"
    _path_src="${_desc_src}"
fi


#echo "USERNAME = ${_username}"
#echo "PASSWORD = ${_password}"
#echo "HOSTNAME = ${_hostname}"
#echo "PORT_NUM = ${_portnum}"
#echo "SRC_PATH = ${_path_src}"
#echo "DST_PATH = ${_path_dst}"
#echo "IS_R_2_L = ${_remote_to_local}"


generate_setting_command
generate_connect_command "${_username}" "${_password}" "${_hostname}" "${_portnum}"
generate_list_remote_command
generate_disconnect_command
generate_end_command

exit


# MAIN PROCESS
check_binary || ( _result=$?; echo "Required binary file is not found."; exit ${_result} )

 
[ -z "${_host}" ] && log_err_message "No host is specified." && exit 255
[ -z "${_directory_source}" ] && log_err_message "Source directory is not specified." && exit 255
[ -z "${_password}" ] && log_err_message "Password is not set." && exit 255

_user="${_user:-$USER}"
_directory_target="${_directory_target:-.}"

log_info_message "Login user is ${_user}."
log_info_message "Source directory is localhost:${_directory_source}."
log_info_message "Destination directory is ${_host}:${_directory_destination}."


_n_warns=0
{
    generate_connect_string "${_user}" "${_host}" "${_password}"

    #generate_multi_put_string $(list_subdirectories_in "${_directory_source}")

   # echo "ls"
   # for _f in $(find "${_directory}" -type f)
   # do
   #     generate_multi_put_string "${_f}"
   # done
    generate_disconnect_string
}
#
#} > >(${_ftp})
 
log_info_message "Process is finished with ${_n_warns} warning(s)."
exit 0

