#!/bin/bash
 
__ping="/bin/ping"
__lftp="/usr/bin/lftp"
__getopt="/usr/bin/getopt"



for __ in "$(dirname $0)/lib-"* ; do . "${__}" ; done



check_binary()
{
    [ -x "${__ping}" ] || return ${EXITCODE_ERROR}
    [ -x "${__lftp}" ] || return ${EXITCODE_ERROR}
    [ -x "${__getopt}" ] || return ${EXITCODE_ERROR}

    return ${EXITCODE_NO_ERROR}
}


show_usage()
{
    cat <<TXT
Usage: $0 -s source_description -d destination_description
    Local Description: \${LOCAL_PATH}
    Remote Description: \${REMOTE_USER}:\${REMOTE_PASSWORD}@\${REMOTE_HOST}:\${REMOTE_PORT}:\${REMOTE_PATH} 
TXT
    exit ${EXITCODE_WARNING}
}


generate_setting_command()
{
    cat <<CMD
set ftp:passive-mode off
set ftp:ssl-force on
set ftp:ssl-allow on
set ftp:ssl-protect-data on
set ssl:verify-certificate off
CMD

    return ${EXITCODE_NO_ERROR}
}


generate_connect_command()
{
    local _user="${1}"
    local _pass="${2}"
    local _host="${3}"
    local _port="${4}"

    [ -z "${_user}" ] && return ${EXITCODE_ERROR}
    [ -z "${_pass}" ] && return ${EXITCODE_ERROR}
    [ -z "${_host}" ] && return ${EXITCODE_ERROR}
    [ -z "${_port}" ] && return ${EXITCODE_ERROR}

    cat <<CMD
open -u ${_user},${_pass} -p ${_port} ${_host}
CMD

    return ${EXITCODE_NO_ERROR}
}


generate_disconnect_command()
{
    cat <<CMD
close
CMD

    return ${EXITCODE_NO_ERROR}
}


generate_end_command()
{
    cat <<CMD
quit
CMD

    return ${EXITCODE_NO_ERROR}
}


_generate_simple_command()
{
    local _command="${1}"

    [ -z "${_command}" ] && return ${EXITCODE_ERROR}

    cat <<CMD
${1}
CMD

    return ${EXITCODE_NO_ERROR}
}


generate_list_remote_command()
{
    _generate_simple_command "ls"

    return $?
}


_generate_mirror_command()
{
    local _s="${1}"; shift

    [ -z "${_s}" ] && return ${EXITCODE_ERROR}
    [ -z "${_d}" ] && return ${EXITCODE_ERROR}

    cat <<CMD
mirror -a -e ${_o} --verbose=0 ${_s} ${_d}
CMD
}


generate_mirror_local_command()
{
    #local _s_remote="${1}"
    #local _d_local="${2}"

    _generate_mirror_command "${1}" "${2}" ""

    return ${?}
}


generate_mirror_remote_command()
{
    #local _s_local="${1}"
    #local _d_remote="${2}"

    _generate_mirror_command "${1}" "${2}" "-R"

    return ${?}
}


show_usage
exit
#generate_setting_command
#generate_connect_command
#generate_list_remote_command
#generate_mirror_local_command "~/testdir" "/tmp/"
#generate_mirror_remote_command "/tmp/testdir" "~/"
#generate_disconnect_command
#generate_end_command



# MAIN PROCESS
check_binary || ( _result=$?; echo "Required binary file is not found."; exit ${_result} )

_hostname=
_username=
_password=
_portnum=
_path_s_dir=
_path_d_dir=
while getopts s:d: OPT
do
    case "${OPT}" in
    h)
        _host="${OPTARG}"
        ;;

    u)
        _user="${OPTARG}"
        ;;
 
    s)
        _directory_source="${OPTARG}"
        ;;

    d)
        _directory_destination="${OPTARG}"
        ;;
 
    p)
        _password="${OPTARG}"
        ;;
 
    \?)
        show_usage
        ;;
    esac
done
 
 
[ -z "${_host}" ] && log_err_message "No host is specified." && exit 255
[ -z "${_directory_source}" ] && log_err_message "Source directory is not specified." && exit 255
[ -z "${_password}" ] && log_err_message "Password is not set." && exit 255

_user="${_user:-$USER}"
_directory_target="${_directory_target:-.}"

log_info_message "Login user is ${_user}."
log_info_message "Source directory is localhost:${_directory_source}."
log_info_message "Destination directory is ${_host}:${_directory_destination}."


_n_warns=0
{
    generate_connect_string "${_user}" "${_host}" "${_password}"

    #generate_multi_put_string $(list_subdirectories_in "${_directory_source}")

   # echo "ls"
   # for _f in $(find "${_directory}" -type f)
   # do
   #     generate_multi_put_string "${_f}"
   # done
    generate_disconnect_string
}
#
#} > >(${_ftp})
 
log_info_message "Process is finished with ${_n_warns} warning(s)."
exit 0

